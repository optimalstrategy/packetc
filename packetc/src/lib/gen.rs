use std::fmt::Write;

use super::*;

const VERSION: Option<&'static str> = option_env!("CARGO_PKG_VERSION");

macro_rules! append {
    ($dst:expr, $($arg:tt)*) => (write!($dst, $($arg)*).unwrap());

    ($dst:expr, $arg:expr) => (write!($dst, "{}", $arg).unwrap());
}

pub trait Kind {}
#[derive(Clone, Copy, PartialEq, Debug, Default)]
pub struct TypeScript;
impl Kind for TypeScript {}
#[derive(Clone, Copy, PartialEq, Debug, Default)]
pub struct Rust;
impl Kind for Rust {}

#[derive(Clone, PartialEq, Debug, Default)]
pub struct Generator<K: Kind> {
    kind: std::marker::PhantomData<K>,
    buffer: String,
}

impl<K: Kind> Generator<K> {
    pub fn new() -> Self {
        Generator {
            kind: std::marker::PhantomData {},
            buffer: String::new(),
        }
    }

    pub fn push_meta(&mut self) {
        append!(
            &mut self.buffer,
            "// Generated by packetc v{} at {}\n",
            VERSION.unwrap_or("???"),
            chrono::Utc::now().to_rfc2822()
        );
    }

    pub fn push_line(&mut self) {
        append!(&mut self.buffer, "\n");
    }

    pub fn push_def(&mut self, name: String, which: &impl Definition<K>) {
        which.gen_def(name, &mut self.buffer);
    }

    pub fn push_write_impl(&mut self, name: String, which: &impl WriteImpl<K>) {
        which.gen_write_impl(name, &mut self.buffer);
    }

    pub fn push_read_impl(&mut self, name: String, which: &impl ReadImpl<K>) {
        which.gen_read_impl(name, &mut self.buffer);
    }

    pub fn finish(mut self) -> String {
        std::mem::take(&mut self.buffer)
    }
}

fn indent(num: usize) -> String {
    "    ".repeat(num)
}

pub trait WriteImpl<K: Kind> {
    fn gen_write_impl(&self, name: String, out: &mut String);
}

pub trait ReadImpl<K: Kind> {
    fn gen_read_impl(&self, name: String, out: &mut String);
}

fn rust_gen_write_impl_builtin(
    id: &mut usize,
    fname_stack: &mut Vec<String>,
    name: &str,
    ty: &check::Builtin,
    array: bool,
    indentation: &mut usize,
    out: &mut String,
) {
    *id += 1;
    // TODO: check sizes
    // TODO: DRY
    fname_stack.push(name.to_string());
    if array {
        append!(
            out,
            "{}for n_{} in self.{}{}iter() {{\n",
            indent(*indentation),
            *id,
            fname_stack.join("."),
            if fname_stack.len() > 1 { "." } else { "" }
        );
        *indentation += 1;
    }
    let varname = if array {
        format!("n_{}", *id)
    } else {
        format!("self.{}", fname_stack.join("."))
    };
    match ty {
        check::Builtin::Uint8 => {
            append!(
                out,
                "{}writer.write_uint8({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Uint16 => {
            append!(
                out,
                "{}writer.write_uint16({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Uint32 => {
            append!(
                out,
                "{}writer.write_uint32({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Int8 => {
            append!(
                out,
                "{}writer.write_int8({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Int16 => {
            append!(
                out,
                "{}writer.write_int16({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Int32 => {
            append!(
                out,
                "{}writer.write_int32({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::Float => {
            append!(
                out,
                "{}writer.write_float({});\n",
                indent(*indentation),
                varname
            )
        }
        check::Builtin::String => {
            append!(
                out,
                "{}writer.write_slice(&{}.as_bytes());\n",
                indent(*indentation),
                varname
            )
        }
    };
    if array {
        *indentation -= 1;
        append!(out, "{}}}\n", indent(*indentation));
    }
    fname_stack.pop();
}

fn rust_gen_write_impl_enum(
    id: &mut usize,
    fname_stack: &mut Vec<String>,
    name: &str,
    ty: &check::Enum,
    array: bool,
    indentation: &mut usize,
    out: &mut String,
) {
    *id += 1;
    // TODO: check sizes
    // TODO: DRY
    fname_stack.push(name.to_string());
    if array {
        append!(
            out,
            "{}for n_{} in self.{}{}iter() {{\n",
            indent(*indentation),
            *id,
            fname_stack.join("."),
            if fname_stack.len() > 1 { "." } else { "" }
        );
        *indentation += 1;
    }
    let varname = if array {
        format!("n_{}", *id)
    } else {
        format!("self.{}", fname_stack.join("."))
    };
    match ty.repr {
        check::EnumRepr::U8 => append!(
            out,
            "{}writer.write_uint8({} as u8)",
            indent(*indentation),
            varname,
        ),
        check::EnumRepr::U16 => append!(
            out,
            "{}writer.write_uint16({} as u16)",
            indent(*indentation),
            varname,
        ),
        check::EnumRepr::U32 => append!(
            out,
            "{}writer.write_uint32({} as u32)",
            indent(*indentation),
            varname,
        ),
    };
    if array {
        *indentation -= 1;
        append!(out, "{}}}\n", indent(*indentation));
    }
    fname_stack.pop();
}

fn rust_gen_write_impl_struct(
    id: &mut usize,
    fname_stack: &mut Vec<String>,
    name: &str,
    push_name: bool,
    ty: &check::Struct,
    array: bool,
    indentation: &mut usize,
    out: &mut String,
) {
    *id += 1;
    // TODO: check sizes
    // TODO: dry
    if push_name {
        fname_stack.push(name.to_string());
    }
    if array {
        append!(
            out,
            "{}for n_{} in self.{}.iter() {{\n",
            indent(*indentation),
            *id,
            fname_stack.join(".")
        );
        *indentation += 1;
    }
    let mut array_fname_stack = vec![format!("n_{}", *id)];
    for field in ty.fields.iter() {
        let field_type = &*field.r#type.borrow();
        match &field_type.1 {
            check::ResolvedType::Builtin(builtin) => rust_gen_write_impl_builtin(
                id,
                if array {
                    &mut array_fname_stack
                } else {
                    fname_stack
                },
                &field.name,
                builtin,
                field.array,
                indentation,
                out,
            ),
            check::ResolvedType::Enum(r#enum) => rust_gen_write_impl_enum(
                id,
                if array {
                    &mut array_fname_stack
                } else {
                    fname_stack
                },
                &field.name,
                r#enum,
                field.array,
                indentation,
                out,
            ),
            check::ResolvedType::Struct(r#struct) => rust_gen_write_impl_struct(
                id,
                if array {
                    &mut array_fname_stack
                } else {
                    fname_stack
                },
                &field.name,
                true,
                r#struct,
                field.array,
                indentation,
                out,
            ),
        }
    }
    if array {
        *indentation -= 1;
        append!(out, "{}}}\n", indent(*indentation));
    }
    if push_name {
        fname_stack.pop();
    }
}

impl WriteImpl<Rust> for check::Export {
    fn gen_write_impl(&self, name: String, out: &mut String) {
        let mut id = 0usize;
        let mut indentation = 0usize;
        append!(out, "{}impl {} {{\n", indent(indentation), name);

        indentation += 1;
        append!(
            out,
            "{}pub fn write(&self, writer: &mut Writer) {{\n",
            indent(indentation)
        );
        indentation += 1;
        rust_gen_write_impl_struct(
            &mut id,
            &mut vec![],
            &String::new(),
            false,
            &self.r#struct,
            false,
            &mut indentation,
            out,
        );
        indentation -= 1;
        append!(out, "{}}}\n", indent(indentation));
        indentation -= 1;

        append!(out, "{}}}\n", indent(indentation));
    }
}

pub trait Definition<K: Kind> {
    fn gen_def(&self, name: String, out: &mut String);
}

impl Definition<Rust> for check::Builtin {
    fn gen_def(&self, name: String, out: &mut String) {
        match self {
            check::Builtin::Uint8 => append!(out, "pub type {} = u8;\n", name),
            check::Builtin::Uint16 => append!(out, "pub type {} = u16;\n", name),
            check::Builtin::Uint32 => append!(out, "pub type {} = u32;\n", name),
            check::Builtin::Int8 => append!(out, "pub type {} = i8;\n", name),
            check::Builtin::Int16 => append!(out, "pub type {} = i16;\n", name),
            check::Builtin::Int32 => append!(out, "pub type {} = i32;\n", name),
            check::Builtin::Float => append!(out, "pub type {} = f32;\n", name),
            check::Builtin::String => append!(out, "pub type {} = String;\n", name),
        }
    }
}

impl Definition<Rust> for check::Struct {
    fn gen_def(&self, name: String, out: &mut String) {
        append!(out, "pub struct {} {{\n", name);
        for field in self.fields.iter() {
            let typename = &(*field.r#type.borrow()).0;
            if field.array {
                append!(out, "    pub {}: Vec<{}>,\n", field.name, typename);
            } else {
                append!(out, "    pub {}: {},\n", field.name, typename);
            }
        }
        append!(out, "}}\n");
    }
}

impl Definition<Rust> for check::Enum {
    fn gen_def(&self, type_name: String, out: &mut String) {
        append!(out, "#[repr({})]\n", self.repr);
        append!(out, "pub enum {} {{\n", type_name);
        for variant in self.variants.iter() {
            append!(out, "    {} = 1 << {},\n", variant.name, variant.value);
        }
        append!(out, "}}\n");
    }
}

impl Definition<TypeScript> for check::Builtin {
    fn gen_def(&self, name: String, out: &mut String) {
        match self {
            check::Builtin::Uint8 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Uint16 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Uint32 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Int8 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Int16 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Int32 => append!(out, "export type {} = number;\n", name),
            check::Builtin::Float => append!(out, "export type {} = number;\n", name),
            _ => (),
        }
    }
}

impl Definition<TypeScript> for check::Struct {
    fn gen_def(&self, name: String, out: &mut String) {
        append!(out, "export interface {} {{\n", name);
        for field in self.fields.iter() {
            let typename = &(*field.r#type.borrow()).0;
            if field.array {
                append!(out, "    {}: {}[],\n", field.name, typename);
            } else {
                append!(out, "    {}: {},\n", field.name, typename);
            }
        }
        append!(out, "}}\n");
    }
}

impl Definition<TypeScript> for check::Enum {
    fn gen_def(&self, type_name: String, out: &mut String) {
        append!(out, "export const enum {} {{\n", type_name);
        for variant in self.variants.iter() {
            append!(out, "    {} = 1 << {},\n", variant.name, variant.value);
        }
        append!(out, "}}\n");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn rust_simple_struct_definition() {
        use check::*;
        let test = Struct {
            fields: vec![
                StructField {
                    name: "testA".to_string(),
                    r#type: Ptr::new((
                        "uint8".to_string(),
                        check::ResolvedType::Builtin(check::Builtin::Uint8),
                    )),
                    array: false,
                },
                StructField {
                    name: "testB".to_string(),
                    r#type: Ptr::new((
                        "uint8".to_string(),
                        check::ResolvedType::Builtin(check::Builtin::Uint8),
                    )),
                    array: false,
                },
            ],
        };
        let mut gen = Generator::<Rust>::new();
        gen.push_line();
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
pub struct Test {
    pub testA: uint8,
    pub testB: uint8,
}
"
        );
    }

    #[test]
    fn rust_simple_enum_definition() {
        use check::*;
        let test = Enum {
            repr: EnumRepr::U8,
            variants: vec![
                EnumVariant {
                    name: "A".to_string(),
                    value: 0,
                },
                EnumVariant {
                    name: "B".to_string(),
                    value: 1,
                },
            ],
        };
        let mut gen = Generator::<Rust>::new();
        gen.push_line();
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
#[repr(u8)]
pub enum Test {
    A = 1 << 0,
    B = 1 << 1,
}
"
        );
    }

    #[test]
    fn rust_complex_struct_definition() {
        use check::*;
        let position = Struct {
            fields: vec![
                StructField {
                    name: "x".to_string(),
                    r#type: Ptr::new(("float".to_string(), ResolvedType::Builtin(Builtin::Float))),
                    array: false,
                },
                StructField {
                    name: "y".to_string(),
                    r#type: Ptr::new(("float".to_string(), ResolvedType::Builtin(Builtin::Float))),
                    array: false,
                },
            ],
        };
        let test = Struct {
            fields: vec![
                StructField {
                    name: "testA".to_string(),
                    r#type: Ptr::new(("uint8".to_string(), ResolvedType::Builtin(Builtin::Uint8))),
                    array: false,
                },
                StructField {
                    name: "testB".to_string(),
                    r#type: Ptr::new((
                        "string".to_string(),
                        ResolvedType::Builtin(Builtin::String),
                    )),
                    array: true,
                },
                StructField {
                    name: "position".to_string(),
                    r#type: Ptr::new((
                        "Position".to_string(),
                        ResolvedType::Struct(position.clone()),
                    )),
                    array: false,
                },
            ],
        };
        let mut gen = Generator::<Rust>::new();
        gen.push_line();
        gen.push_def("string".to_string(), &Builtin::String);
        gen.push_def("uint8".to_string(), &Builtin::Uint8);
        gen.push_def("float".to_string(), &Builtin::Float);
        gen.push_def("Position".to_string(), &position);
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
pub type string = String;
pub type uint8 = u8;
pub type float = f32;
pub struct Position {
    pub x: float,
    pub y: float,
}
pub struct Test {
    pub testA: uint8,
    pub testB: Vec<string>,
    pub position: Position,
}
"
        );
    }

    #[test]
    fn ts_simple_struct_definition() {
        use check::*;
        let test = Struct {
            fields: vec![
                StructField {
                    name: "testA".to_string(),
                    r#type: Ptr::new((
                        "uint8".to_string(),
                        check::ResolvedType::Builtin(check::Builtin::Uint8),
                    )),
                    array: false,
                },
                StructField {
                    name: "testB".to_string(),
                    r#type: Ptr::new((
                        "uint8".to_string(),
                        check::ResolvedType::Builtin(check::Builtin::Uint8),
                    )),
                    array: false,
                },
            ],
        };
        let mut gen = Generator::<TypeScript>::new();
        gen.push_line();
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
export interface Test {
    testA: uint8,
    testB: uint8,
}
"
        );
    }

    #[test]
    fn ts_simple_enum_definition() {
        use check::*;
        let test = Enum {
            repr: EnumRepr::U8,
            variants: vec![
                EnumVariant {
                    name: "A".to_string(),
                    value: 0,
                },
                EnumVariant {
                    name: "B".to_string(),
                    value: 1,
                },
            ],
        };
        let mut gen = Generator::<TypeScript>::new();
        gen.push_line();
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
export const enum Test {
    A = 1 << 0,
    B = 1 << 1,
}
"
        );
    }

    #[test]
    fn ts_complex_struct_definition() {
        use check::*;
        let position = Struct {
            fields: vec![
                StructField {
                    name: "x".to_string(),
                    r#type: Ptr::new(("float".to_string(), ResolvedType::Builtin(Builtin::Float))),
                    array: false,
                },
                StructField {
                    name: "y".to_string(),
                    r#type: Ptr::new(("float".to_string(), ResolvedType::Builtin(Builtin::Float))),
                    array: false,
                },
            ],
        };
        let test = Struct {
            fields: vec![
                StructField {
                    name: "testA".to_string(),
                    r#type: Ptr::new(("uint8".to_string(), ResolvedType::Builtin(Builtin::Uint8))),
                    array: false,
                },
                StructField {
                    name: "testB".to_string(),
                    r#type: Ptr::new((
                        "string".to_string(),
                        ResolvedType::Builtin(Builtin::String),
                    )),
                    array: true,
                },
                StructField {
                    name: "position".to_string(),
                    r#type: Ptr::new((
                        "Position".to_string(),
                        ResolvedType::Struct(position.clone()),
                    )),
                    array: false,
                },
            ],
        };

        let mut gen = Generator::<TypeScript>::new();
        gen.push_line();
        gen.push_def("string".to_string(), &Builtin::String);
        gen.push_def("string".to_string(), &Builtin::String);
        gen.push_def("uint8".to_string(), &Builtin::Uint8);
        gen.push_def("float".to_string(), &Builtin::Float);
        gen.push_def("Position".to_string(), &position);
        gen.push_def("Test".to_string(), &test);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
export type uint8 = number;
export type float = number;
export interface Position {
    x: float,
    y: float,
}
export interface Test {
    testA: uint8,
    testB: string[],
    position: Position,
}
"
        );
    }

    #[test]
    fn rust_simple_struct_impl() {
        use check::*;
        let position = Export {
            r#struct: Struct {
                fields: vec![
                    StructField {
                        name: "x".to_string(),
                        r#type: Ptr::new((
                            "float".to_string(),
                            ResolvedType::Builtin(Builtin::Float),
                        )),
                        array: false,
                    },
                    StructField {
                        name: "y".to_string(),
                        r#type: Ptr::new((
                            "float".to_string(),
                            ResolvedType::Builtin(Builtin::Float),
                        )),
                        array: false,
                    },
                ],
            },
        };
        let mut gen = Generator::<Rust>::new();
        gen.push_line();
        gen.push_write_impl("Position".to_string(), &position);
        let actual = gen.finish();
        assert_eq!(
            actual,
            "
impl Position {
    pub fn write(&self, writer: &mut Writer) {
        writer.write_float(self.x);
        writer.write_float(self.y);
    }
}
"
        );
    }
}
