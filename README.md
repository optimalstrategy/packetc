# packetc

This repository holds a schema->parser compiler for a binary format intended for usage in bandwidth and latency constrained environments (such as real-time games).

See [format.md](format.md) for rationale.

# Usage

Install the compiler

```s
$ cargo install --git https://github.com/EverCrawl/packetc.git
```

Write a schema

```s
$ echo "Test: struct {
    value: uint8
}
export Test" > test.pkt
```

Compile it: `packetc <lang> <input> <output>`

```s
$ packetc rust test.pkt test.rs
```

Which will output:

```rust
// Generated by packetc v0.1.4 at Mon, 1 Jan 1900 00:00:00 +0000
#![allow(dead_code, non_camel_case_types, unused_imports, clippy::field_reassign_with_default)]
use std::convert::TryFrom;
#[derive(Clone, PartialEq, Debug, Default)]
pub struct Test {
    pub value: u8,
}
pub fn read(reader: &mut packet::reader::Reader, output: &mut Test) -> Result<(), packet::Error> {
    output.value = reader.read_uint8()?;
    Ok(())
}
pub fn write(writer: &mut packet::writer::Writer, input: &Test) {
    writer.write_uint8(input.value);
}
```

Add a dependency on `packet-rs` to your project:

```toml
packet = { package = "packet-rs", git = "https://github.com/EverCrawl/packet-rs.git" }
```

Then include the generated file somewhere in your project...

```rust
// main.rs

mod test;

fn main() {
    // receive some bytes, probably from a socket
    let data = &[0];
    // read the data
    let mut reader = packet::Reader::new(data);
    let mut test = test::Test::default();
    test::read(&mut reader, &mut test).unwrap();
}
```

You can see real usage of the compiler in the [EverCrawl](https://github.com/EverCrawl) project.


# TODO

- Currently, reading data is really cumbersome, even though it doesn't have to be
  - accept only &[u8] into impl::read() and in impl::read() body, use Reader::new(data) and impl::Export::default(), instead of requiring the user pass those into impl::read(), because no allocations will happen anyway
- De-duplicate the code in src/lib/gen 
  - use macros to provide common operations, or use more "partial" generators which can be composed better